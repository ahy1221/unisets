% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/AllGenerics.R, R/AllMethods.R,
%   R/BaseSets-class.R
\docType{methods}
\name{BaseSets-methods}
\alias{BaseSets-methods}
\alias{relations}
\alias{relations<-}
\alias{elements}
\alias{elementData}
\alias{elementData<-}
\alias{sets}
\alias{setData}
\alias{setData<-}
\alias{nElements}
\alias{nSets}
\alias{setLengths}
\alias{elementLengths}
\alias{relations,BaseSets-method}
\alias{relations<-,BaseSets-method}
\alias{elementData,BaseSets-method}
\alias{elementData<-,BaseSets-method}
\alias{setData,BaseSets-method}
\alias{setData<-,BaseSets-method}
\alias{elements,BaseSets-method}
\alias{sets,BaseSets-method}
\alias{length,BaseSets-method}
\alias{nElements,BaseSets-method}
\alias{nSets,BaseSets-method}
\alias{setLengths,BaseSets-method}
\alias{elementLengths,BaseSets-method}
\alias{[,BaseSets,ANY,ANY,ANY-method}
\alias{[,BaseSets-method}
\alias{subset.BaseSets}
\alias{subset,BaseSets-method}
\alias{duplicated,BaseSets-method}
\alias{unique,BaseSets-method}
\alias{as.DataFrame.BaseSets}
\alias{as.DataFrame}
\alias{as.data.frame.BaseSets}
\alias{as.data.frame}
\alias{as.list.BaseSets}
\alias{as.list}
\alias{as.matrix.BaseSets}
\alias{as.matrix}
\alias{as.FuzzySets.BaseSets}
\alias{as.GOSets.BaseSets}
\alias{as.BaseSets.list}
\alias{as.BaseSets}
\alias{as.BaseSets.matrix}
\title{Methods for \code{BaseSets} Objects}
\usage{
relations(object)

relations(object) <- value

elements(object)

elementData(object)

elementData(object) <- value

sets(object)

setData(object)

setData(object) <- value

nElements(object)

nSets(object)

setLengths(object)

elementLengths(object)

\S4method{relations}{BaseSets}(object)

\S4method{relations}{BaseSets}(object) <- value

\S4method{elementData}{BaseSets}(object)

\S4method{elementData}{BaseSets}(object) <- value

\S4method{setData}{BaseSets}(object)

\S4method{setData}{BaseSets}(object) <- value

\S4method{elements}{BaseSets}(object)

\S4method{sets}{BaseSets}(object)

\S4method{length}{BaseSets}(x)

\S4method{nElements}{BaseSets}(object)

\S4method{nSets}{BaseSets}(object)

\S4method{setLengths}{BaseSets}(object)

\S4method{elementLengths}{BaseSets}(object)

\S4method{[}{BaseSets,ANY,ANY,ANY}(x, i, j, ..., drop = TRUE)

\method{subset}{BaseSets}(x, ...)

\S4method{duplicated}{BaseSets}(x, incomparables = FALSE, ...)

\S4method{unique}{BaseSets}(x, incomparables = FALSE, ...)

as.DataFrame.BaseSets(object, ...)

\method{as.data.frame}{BaseSets}(x, ...)

\method{as.list}{BaseSets}(x, ...)

\method{as.matrix}{BaseSets}(x, ...)

as.BaseSets.list(list, ...)

as.BaseSets.matrix(matrix, ...)
}
\arguments{
\item{object, x}{An object of class inheriting from \code{\linkS4class{BaseSets}}.}

\item{value}{An object of a class specified in the S4 method signature or as outlined in 'Accessors'.}

\item{i}{index specifying elements to extract or replace.}

\item{j, drop}{Ignored.}

\item{...}{Additional arguments passed to and from other methods.}

\item{incomparables}{Ignored.}

\item{list}{A \code{list} of named character vectors.
The names are taken as the set identifiers.
The character vectors are taken as identifiers of elements that are member of each set.}

\item{matrix}{A \code{matrix}.
The matrix will be coerced to \code{logical} type and relations indicating \code{TRUE} will be stored in the \code{BaseSets}.}
}
\description{
This page documents the S4 generics and methods defined for objects inheriting of the \code{\linkS4class{BaseSets}} class.
In the usage below, \code{object} and \code{x} represent an object of class inheriting from \code{\linkS4class{BaseSets}},
and \code{value} is an object of a class specified in the S4 method signature or as outlined in 'Accessors'.
}
\section{Accessors}{

\code{relations(object)} returns the \code{relations} slot.
A \code{Hits} objets storing the integer index of elements (\code{from}) and sets (\code{to}) in the \code{elementData} and \code{setData} slots, respectively, and associated relation metadata (\code{mcols}).


\code{elementData(object)} returns the \code{elementData} slot.
An \code{\linkS4class{IdVector}} objets storing the unique element identifiers (\code{ids}) and associated element metadata (\code{mcols}).


\code{setData(object)} returns the \code{setData} slot.
An \code{\linkS4class{IdVector}} objets storing the unique set identifiers (\code{ids}) and associated set metadata (\code{mcols}).


\code{elements(object)} returns an \code{\linkS4class{IdVector}} element identifiers and associated metadata as ordered in \code{relations(object)$element}
(i.e., of length equal to \code{length(object)}).


\code{sets(object)} returns an \code{\linkS4class{IdVector}} of set identifiers and associated metadata as ordered in \code{relations(object)$set}.
(i.e., of length equal to \code{length(object)}).
}

\section{Dimensions}{

\code{length(x)} returns the total count of relations.


\code{nElements(object)} returns the count of unique elements.


\code{nSets(object)} returns the count of unique sets.


\code{setLengths(object)} returns the count of relations per set.


\code{elementLengths(object)} returns the count of relations per element.
}

\section{Subsetting}{

\code{x[i]} returns new \code{\linkS4class{BaseSets}} object of the same class as \code{x} made of the elements selected by \code{i}. \code{i} can be missing; an \code{NA}-free logical, numeric, or character vector or factor (as ordinary vector or \code{\link{Rle}} object); or an \code{\link[=IntegerRanges-class]{IntegerRanges}} object.



\code{subset(object, subset, ...)} returns subsets of relations which meet conditions.
The \code{subset} argument should be a logical expression referring to any of \code{"element"}, \code{"set"}, and any available relation metadata indicating elements or rows to keep: missing values are taken as false.
In addition, metadata for elements and sets that are not represented in the remaining relations are also dropped.
}

\section{Duplication and uniqueness}{

\code{duplicated(x)} determines which relations of a \code{BaseSets} are duplicates of relations with smaller subscripts, and returns a logical vector indicating which relations are duplicates.



\code{unique(x)} returns a \code{BaseSets} like \code{x} but with duplicate relations removed.
}

\section{Coercion from BaseSets}{

\code{as(object, "DataFrame")} and \code{as.DataFrame(object)} return a nested \code{DataFrame} including columns \code{"element"}, \code{"set"}, \code{"relationData"}, \code{"elementData"}, and \code{"setData"}.


\code{as(x, "data.frame")} and \code{as.data.frame(x)}  return a flattened \code{data.frame} including \code{"element"}, \code{"set"}, and columns in \code{mcols(relations(x))} if any.


\code{as(x, "list")} and \code{as.list(x)} return a named \code{list}.
Names are set identifiers, and values are character vectors of element identifiers.


\code{as(x, "matrix")} and \code{as.matrix(x)} return a \code{matrix} with elements as rows, sets as columns, and a \code{logical} value to indicate membership.
}

\section{Coercion to BaseSets}{

\code{as(list, "BaseSets")} and \code{as.BaseSets(object)} return a \code{BaseSets} from a list of character vectors.


\code{as(matrix, "BaseSets")} and \code{as.BaseSets(object)} return a \code{BaseSets} from an incidence matrix.
}

\examples{
# Constructor ----

# Visually intuitive definition of sets
sets <- list(
  set1=c("A", "B"),
  set2=c("B", "C", "D"),
  set3=c("E"))

bs <- as(sets, "BaseSets")
bs

# Accessors ----

relations(bs)

bs1 <- bs
mcols(relations(bs1))[["NEW"]] <- paste0("value", seq_len(length(bs1)))

elementData(bs)

bs1 <- bs
mcols(elementData(bs1))[["NEW"]] <- paste0("value", seq_len(nElements(bs1)))

setData(bs)

bs1 <- bs
mcols(setData(bs1))[["NEW"]] <- paste0("value", seq_len(nSets(bs1)))

elements(bs)
ids(elements(bs))
mcols(elements(bs))

sets(bs)
ids(sets(bs))
mcols(sets(bs))

# Dimensions ----

length(bs)
nElements(bs)
nSets(bs)
setLengths(bs)
elementLengths(bs)

# Subsetting ----

bs1 <- bs[1:5]
bs1 <- bs[1:5, , drop=FALSE] # keep metadat of orphan elements and sets

bs1 <- subset(bs, set == "set1" | element == "E")
bs1

# Duplication and uniqueness ----

bs1 <- bs
relations(bs1) <- rep(relations(bs1), each=2)
table(duplicated(bs1))
unique(bs1)

# Coercion from BaseSets ----

DF1 <- as(bs, "DataFrame")

df1 <- as(bs, "data.frame")

l1 <- as(bs, "list")

m1 <- as(bs, "matrix")

bs1 <- bs
mcols(relations(bs1))[["membership"]] <- runif(length(bs1))
fs <- as(bs1, "FuzzySets")

# Fetch a sample of GO annotations
library(org.Hs.eg.db)
gs <- import(org.Hs.egGO)
bs1 <- as(gs, "BaseSets")
gs1 <- as(bs1, "GOSets")

# Coercion to BaseSets ----

# list
bs1 <- as(list(set1=c("A", "B"), set2=c("B", "C")), "BaseSets")
# matrix
bs1 <- as(m1, "BaseSets")
}
\seealso{
\code{\linkS4class{BaseSets}}.
}
\author{
Kevin Rue-Albrecht
}
